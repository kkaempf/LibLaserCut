/**
 * This file is part of LibLaserCut.
 * Copyright (C) 2017 - 2019 Klaus KÃ¤mpf <kkaempf@suse.de>
 *
 * LibLaserCut is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * LibLaserCut is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with LibLaserCut. If not, see <http://www.gnu.org/licenses/>.
 *
 **/

package de.thomas_oster.liblasercut.drivers.ruida;

import java.util.stream.Stream;
import java.io.IOException;
import java.io.OutputStream;

class ByteStream
{
  private static final byte[] encode_table = {
    (byte)0x89, 0x09, (byte)0x8b, 0x0b, (byte)0x8d, 0x0d, (byte)0x8f, 0x0f, (byte)0x81, 0x01, (byte)0x83, 0x03, (byte)0x85, 0x05, (byte)0x87, 0x07,
    (byte)0x99, 0x19, (byte)0x9b, 0x1b, (byte)0x9d, 0x1d, (byte)0x9f, 0x1f, (byte)0x91, 0x11, (byte)0x93, 0x13, (byte)0x95, 0x15, (byte)0x97, 0x17,
    (byte)0xa9, 0x29, (byte)0xab, 0x2b, (byte)0xad, 0x2d, (byte)0xaf, 0x2f, (byte)0xa1, 0x21, (byte)0xa3, 0x23, (byte)0xa5, 0x25, (byte)0xa7, 0x27,
    (byte)0xb9, 0x39, (byte)0xbb, 0x3b, (byte)0xbd, 0x3d, (byte)0xbf, 0x3f, (byte)0xb1, 0x31, (byte)0xb3, 0x33, (byte)0xb5, 0x35, (byte)0xb7, 0x37,
    (byte)0xc9, 0x49, (byte)0xcb, 0x4b, (byte)0xcd, 0x4d, (byte)0xcf, 0x4f, (byte)0xc1, 0x41, (byte)0xc3, 0x43, (byte)0xc5, 0x45, (byte)0xc7, 0x47,
    (byte)0xd9, 0x59, (byte)0xdb, 0x5b, (byte)0xdd, 0x5d, (byte)0xdf, 0x5f, (byte)0xd1, 0x51, (byte)0xd3, 0x53, (byte)0xd5, 0x55, (byte)0xd7, 0x57,
    (byte)0xe9, 0x69, (byte)0xeb, 0x6b, (byte)0xed, 0x6d, (byte)0xef, 0x6f, (byte)0xe1, 0x61, (byte)0xe3, 0x63, (byte)0xe5, 0x65, (byte)0xe7, 0x67,
    (byte)0xf9, 0x79, (byte)0xfb, 0x7b, (byte)0xfd, 0x7d, (byte)0xff, 0x7f, (byte)0xf1, 0x71, (byte)0xf3, 0x73, (byte)0xf5, 0x75, (byte)0xf7, 0x77,
    (byte)0x8a, 0x0a, (byte)0x8c, 0x0c, (byte)0x8e, 0x0e, (byte)0x90, 0x10, (byte)0x82, 0x02, (byte)0x84, 0x04, (byte)0x86, 0x06, (byte)0x88, 0x08,
    (byte)0x9a, 0x1a, (byte)0x9c, 0x1c, (byte)0x9e, 0x1e, (byte)0xa0, 0x20, (byte)0x92, 0x12, (byte)0x94, 0x14, (byte)0x96, 0x16, (byte)0x98, 0x18,
    (byte)0xaa, 0x2a, (byte)0xac, 0x2c, (byte)0xae, 0x2e, (byte)0xb0, 0x30, (byte)0xa2, 0x22, (byte)0xa4, 0x24, (byte)0xa6, 0x26, (byte)0xa8, 0x28,
    (byte)0xba, 0x3a, (byte)0xbc, 0x3c, (byte)0xbe, 0x3e, (byte)0xc0, 0x40, (byte)0xb2, 0x32, (byte)0xb4, 0x34, (byte)0xb6, 0x36, (byte)0xb8, 0x38,
    (byte)0xca, 0x4a, (byte)0xcc, 0x4c, (byte)0xce, 0x4e, (byte)0xd0, 0x50, (byte)0xc2, 0x42, (byte)0xc4, 0x44, (byte)0xc6, 0x46, (byte)0xc8, 0x48,
    (byte)0xda, 0x5a, (byte)0xdc, 0x5c, (byte)0xde, 0x5e, (byte)0xe0, 0x60, (byte)0xd2, 0x52, (byte)0xd4, 0x54, (byte)0xd6, 0x56, (byte)0xd8, 0x58,
    (byte)0xea, 0x6a, (byte)0xec, 0x6c, (byte)0xee, 0x6e, (byte)0xf0, 0x70, (byte)0xe2, 0x62, (byte)0xe4, 0x64, (byte)0xe6, 0x66, (byte)0xe8, 0x68,
    (byte)0xfa, 0x7a, (byte)0xfc, 0x7c, (byte)0xfe, 0x7e, 0x00, (byte)0x80, (byte)0xf2, 0x72, (byte)0xf4, 0x74, (byte)0xf6, 0x76, (byte)0xf8, 0x78
  };

  private static final byte[] decode_table = {
    (byte)0xf6, 0x09, (byte)0x89, 0x0b, (byte)0x8b, 0x0d, (byte)0x8d, 0x0f, (byte)0x8f, 0x01, (byte)0x81, 0x03, (byte)0x83, 0x05, (byte)0x85, 0x07,
    (byte)0x87, 0x19, (byte)0x99, 0x1b, (byte)0x9b, 0x1d, (byte)0x9d, 0x1f, (byte)0x9f, 0x11, (byte)0x91, 0x13, (byte)0x93, 0x15, (byte)0x95, 0x17,
    (byte)0x97, 0x29, (byte)0xa9, 0x2b, (byte)0xab, 0x2d, (byte)0xad, 0x2f, (byte)0xaf, 0x21, (byte)0xa1, 0x23, (byte)0xa3, 0x25, (byte)0xa5, 0x27,
    (byte)0xa7, 0x39, (byte)0xb9, 0x3b, (byte)0xbb, 0x3d, (byte)0xbd, 0x3f, (byte)0xbf, 0x31, (byte)0xb1, 0x33, (byte)0xb3, 0x35, (byte)0xb5, 0x37,
    (byte)0xb7, 0x49, (byte)0xc9, 0x4b, (byte)0xcb, 0x4d, (byte)0xcd, 0x4f, (byte)0xcf, 0x41, (byte)0xc1, 0x43, (byte)0xc3, 0x45, (byte)0xc5, 0x47,
    (byte)0xc7, 0x59, (byte)0xd9, 0x5b, (byte)0xdb, 0x5d, (byte)0xdd, 0x5f, (byte)0xdf, 0x51, (byte)0xd1, 0x53, (byte)0xd3, 0x55, (byte)0xd5, 0x57,
    (byte)0xd7, 0x69, (byte)0xe9, 0x6b, (byte)0xeb, 0x6d, (byte)0xed, 0x6f, (byte)0xef, 0x61, (byte)0xe1, 0x63, (byte)0xe3, 0x65, (byte)0xe5, 0x67,
    (byte)0xe7, 0x79, (byte)0xf9, 0x7b, (byte)0xfb, 0x7d, (byte)0xfd, 0x7f, (byte)0xff, 0x71, (byte)0xf1, 0x73, (byte)0xf3, 0x75, (byte)0xf5, 0x77,
    (byte)0xf7, 0x08, (byte)0x88, 0x0a, (byte)0x8a, 0x0c, (byte)0x8c, 0x0e, (byte)0x8e, 0x00, (byte)0x80, 0x02, (byte)0x82, 0x04, (byte)0x84, 0x06,
    (byte)0x86, 0x18, (byte)0x98, 0x1a, (byte)0x9a, 0x1c, (byte)0x9c, 0x1e, (byte)0x9e, 0x10, (byte)0x90, 0x12, (byte)0x92, 0x14, (byte)0x94, 0x16,
    (byte)0x96, 0x28, (byte)0xa8, 0x2a, (byte)0xaa, 0x2c, (byte)0xac, 0x2e, (byte)0xae, 0x20, (byte)0xa0, 0x22, (byte)0xa2, 0x24, (byte)0xa4, 0x26,
    (byte)0xa6, 0x38, (byte)0xb8, 0x3a, (byte)0xba, 0x3c, (byte)0xbc, 0x3e, (byte)0xbe, 0x30, (byte)0xb0, 0x32, (byte)0xb2, 0x34, (byte)0xb4, 0x36,
    (byte)0xb6, 0x48, (byte)0xc8, 0x4a, (byte)0xca, 0x4c, (byte)0xcc, 0x4e, (byte)0xce, 0x40, (byte)0xc0, 0x42, (byte)0xc2, 0x44, (byte)0xc4, 0x46,
    (byte)0xc6, 0x58, (byte)0xd8, 0x5a, (byte)0xda, 0x5c, (byte)0xdc, 0x5e, (byte)0xde, 0x50, (byte)0xd0, 0x52, (byte)0xd2, 0x54, (byte)0xd4, 0x56,
    (byte)0xd6, 0x68, (byte)0xe8, 0x6a, (byte)0xea, 0x6c, (byte)0xec, 0x6e, (byte)0xee, 0x60, (byte)0xe0, 0x62, (byte)0xe2, 0x64, (byte)0xe4, 0x66,
    (byte)0xe6, 0x78, (byte)0xf8, 0x7a, (byte)0xfa, 0x7c, (byte)0xfc, 0x7e, (byte)0xfe, 0x70, (byte)0xf0, 0x72, (byte)0xf2, 0x74, (byte)0xf4, 0x76
  };

  private Stream<Byte> stream;
  private boolean empty;
  private String name;

  private void _init() {
    this.stream = Stream.of();
    this.empty = true;
  }
  public ByteStream(String name) {
    System.out.println(String.format("ByteStream(%s)", name));
    this.name = name;
    _init();
  }

  public boolean isEmpty() {
    return this.empty;
  }

  public void writeTo(OutputStream out) throws IOException {
    if (out == null) {
      throw new IOException("No output configured");
    }
    System.out.println(String.format("ByteStream(%s).writeTo()", this.name));
    stream.forEach(v -> {
      int i = v & 0xff;
      if (i < 0) {
        i = 256 + i;
      }
      try {
        out.write(encode_table[i]);
      }
      catch (IOException e) {
        System.out.println("ByteStream.writeTo() failed");
      };
    });
    _init();
  }

  public static byte[] decode(byte[] data) {
    for (int i = 0; i < data.length; i++) {
      int val = data[i] & 0xff;
      if (val < 0) {
        /* signed -> unsigned */
        val = 256 + val;
      }
      data[i] = decode_table[val];
    }
    return data;
  }

  /**
   * append hex string
   *
   * convert hex string to byte values
   * https://stackoverflow.com/questions/11208479/how-do-i-initialize-a-byte-array-in-java
   */
  public ByteStream hex(String s) {
    int len = s.length();
    for (int i = 0; i < len; i += 2) {
      byte value = (byte)((Character.digit(s.charAt(i), 16) << 4)
                           + Character.digit(s.charAt(i+1), 16));
      stream = Stream.concat(stream, Stream.of(value));
    }
    this.empty = false;
    return this;
  }

  /**
   * append integer value
   */
  public ByteStream integer(int i) {
    stream = Stream.concat(stream, Stream.of((byte)(i & 0xff)));
    this.empty = false;
    return this;
  }

  /**
   * append string value
   */
  public ByteStream string(String s) {
    s.chars().forEach(i -> this.integer(i));
    return this;
  }

  /**
   * append absolute value
   */
  public ByteStream absolute(double d) {
    long val = (long)d;
    long mask = 0x7f0000000L; /* 35 (5 * 7) bit total */
    /* output 7 bit wise, msb first */
    for (int i = 0; i <= 4; i++) {
      this.integer((int)((val & mask) >> ((4-i)*7))); /* shifts: 28, 21, 14, 7, 0 bits */
      mask = mask >> 7;
    }
    return this;
  }

  /**
   * append relative value
   */
  public ByteStream relative(double d, boolean signed) {
    int val = (int)Math.floor(d);
//    System.out.println("rel" + ((signed)?"Signed":"Unsigned") + "ValueToByteArray(" + d + " -> " + val + ")");
    if (signed) {
      if (val > 8191) {
        //      System.out.println("relValueToByteArray(" + val + ") > 8191");
        throw new IllegalArgumentException("Relative signed value > 8191");
      }
      else if (val < -8192) {
        //      System.out.println("relValueToByteArray(" + val + ") < 8192");
        throw new IllegalArgumentException("Relative signed value < -8192");
      }
      else if (val < 0) {
        val = val + 16384;
      }
    }
    else {
      if (val > 16383) {
        throw new IllegalArgumentException("Relative unsigned value > 16383");
      }
      else if (val < 0) {
        throw new IllegalArgumentException("Relative unsigned value < 0");
      }
    }
    this.integer((byte)((val & 0x3f80) >> 7));
    this.integer((byte)(val & 0x007f));
    return this;
  }

  public ByteStream relativeSigned(double d) {
    return relative(d, true);
  }
  public ByteStream relativeUnsigned(double d) {
    return relative(d, false);
  }
  /**
   * append percent value
   */
  public ByteStream percent(int percent) {
    double val = (double)percent / 0.006103516; // 100/2^14
//    System.out.println("percentValueToByteArray(" + percent + " -> " + val + ")");
    return relativeUnsigned(val);
  }

}
